<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <link rel="stylesheet" href="jscoq/node_modules/bootstrap/dist/css/bootstrap.min.css" />

    <title>Machine-Checked Mathematics</title>
    <link rel="stylesheet" href="local.css" />

    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'
        async></script>
    <script src="Blob.js" type="text/javascript"></script>
    <script src="FileSaver.js" type="text/javascript"></script>

</head>

<body>
    <div id="ide-wrapper" class="toggled">
        <div id="code-wrapper">
            <div id="document">
                <p>
                Use ALT-(up-arrow) and ALT-(down-arrow) to process this document inside your browser, line-by-line. 
		Use ALT-(right-arrow) to go to the cursor. 
                You can
                <span class="save-button" onClick="save_coq_snippets()">save your edits</span>
                inside your browser and
                <span class="save-button" onClick="load_coq_snippets()">load them back</span>.
                <!-- (edits are also saved when you close the window) -->
                Finally, you can
                <span class="save-button" onClick="download_coq_snippets()">download</span>
                your working copy of the file, e.g., for sending it to teachers.
                <hl />
                </p>
<div><textarea id='coq-ta-1'>
From mathcomp Require Import mini_ssreflect.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

(* *** Fill in the holes left below, indicated by a
  (* write here *) comment.
  You can always skip a question:
  - either using comments, (* this is a comment *), e.g., to skip an
    incomplete definition
  - or using the <tt>admit</tt> tactic, to skip a subproof. 
*)

(* *** Exercise 1

 -------------------------------------------------------------------------- *)

Section PredicateOnRelations.

Variables (T : Type) (r : T -> T -> bool).

(* Write the statement expressing that r is a commutative relation on T *)
Definition commutative := (* write here *)
.
End PredicateOnRelations.

(* Write a statement parameterized by a type (T : Type) and a boolean relation
  (r : T -> T -> bool) stating that r is transitive *)

Definition associative (* write here *)
:= 
(* write here *)
.

(* *** Exercise 2

 -------------------------------------------------------------------------- *)

(* The term <tt>erfl t</tt> has type t = t for any term t : T, of type T. *)
Check (erefl 2).

(* The term <tt>eq_ind</tt> expresses that <tt>eq</tt> is a polymorphic binary relation:*)
About eq_ind.
(* Note that the first argument (A : Type) is implicit *)

(* Write an instance of eq_ind witnessing that equality is symmetric. *)
Definition eq_sym (A : Type) (x y : A) (h : x = y) : y = x := (* write here *)
.

(* *** Exercise 3

 -------------------------------------------------------------------------- *)

(* Define a function xor : bool -> bool -> bool for the exclusive
disjunction, i.e such that (xor b1 b2) evaluates to true if and only
if b1 is true and b2 is false, or b1 is false and b2 is true *)

Definition xor (b1 b2 : bool) : bool := (* write here *)
.

(* Show that (bool, xorb, false) has a structure of commutative group. *)

(* associativity *)
Lemma xorA (b1 b2 b3 : bool) : xor (xor b1 b2) b3 = xor b1 (xor b2 b3).
Proof.
(* write here *)
Qed.

(* false is a left neutral for the law *)
Lemma xorFb b : (* write here *)
.
Proof.
(* write here *)
Qed.

(* xorb is commutative *)
Lemma xorC (b1 b2 : bool) : (* write here *)
.
Proof.
(* write here *)
Qed.

(* xorb has an inverse (left or right does not matter, by commutativity *)
Lemma xorI (b : bool) : (* write here *)
.
Proof.
(* write here *)
Qed.

(* *** Exercise 4

 -------------------------------------------------------------------------- *)

Section GeometricSequence.
Variable (a : nat).

Fixpoint u (n : nat) : nat := match n with S m => a * u m | O => 1 end.

(* Use theorem <tt>expnS</tt> to show the following formula *)
Lemma u_eq (n : nat) : u n = a ^ n.
(* Remember /= simplifies by computation, 
            // closes trivial subgoals, 
            //= does both.*)
Proof.
(* write here *)
Qed.

End GeometricSequence.

(* *** Exercise 5

 -------------------------------------------------------------------------- *)

(* Define an inductive type for binary trees (without labels) *)

Inductive tree : Set :=
| Leaf : (* write here*)
| Parent (* write here*) : (* write here*)
.

(* Define a function counting the number of nodes (both leaf and parent nodes) in a tree *)

Fixpoint size  (t : tree) : nat :=
  match t with
  | Leaf => (* write here *)
  | Parent l r => (* write here *)
  end.

(* Define a tree with one node, with three nodes, and test your size function *)

Definition one_tree : tree := (* write here *)
.

Definition three_tree : tree := (* write here *)
.

Eval compute in size one_tree.

Eval compute in size three_tree.

(* Define a function counting the depth of the tree.
Hint: you can use the function
maxn : nat -> nat -> nat
to compute the maximum of two natural numbers.
 *)
Fixpoint depth (t : tree) : nat :=
  match t with
  | Leaf => 0
  | Parent l r => (* write here *)
  end.

(* Test your depth function *)

Eval compute in depth one_tree.

Eval compute in depth three_tree.

Eval compute in depth (Parent Leaf (Parent Leaf Leaf)).

(* State and prove that the size of a binary_tree is always positive. *)
(* Remember that we can ommit the _ = true because of the is_true
  coercion. *)
Lemma le1_size (t : tree) : 1 <= size t.
(* Remember /= simplifies by computation, 
            // closes trivial subgoals, 
            //= does both.*)
Proof.
(* write here *)
Qed.

(* State and prove that the height is smaller than the number of nodes. *)
(* Here are useful lemmas: *)
About leq_trans.
About leq_add2r.
About leq_add2l.
About add1n.
About addn1.

Lemma leq_depth_size (t : tree) : depth t <= size t.
Proof.
elim: t => [| t1 iht1 t2 iht2] //=.
have broken_sym1 : depth t1 <= depth t2 -> S (maxn (depth t1) (depth t2)) <= size t1 + size t2.
  move/maxn_idPr->.
  suff : S (size t2) <= size t1 + size t2.
(* write here *)
admit.
  have -> : S (size t2) = 1 + (size t2).
(* write here *)
admit.
have broken_sym2 : depth t2 <= depth t1 -> S (maxn (depth t1) (depth t2)) <= size t1 + size t2.
  move/maxn_idPl->.
  suff : S (size t1) <= size t1 + size t2.
(* write here *)
admit.
  have -> : S (size t1) = (size t1) + 1.
(* write here *)
admit.
have [le21 | l212] : depth t2 <= depth t1 \/ depth t1 <= depth t2.
  case: leqP=> j; first by left.
  by right; apply: ltnW.
(* write here *)
admit.
(* write here *)
admit.
Qed.
</textarea></div>
<script type="text/javascript">
 var coqdoc_ids = ['coq-ta-1'];
</script>
<hr />

<script type="text/javascript">

  function load_coq_snippets() {
    for (i = 0; i < coqdoc_ids.length; ++i) {
      document.getElementById(coqdoc_ids[i]).nextSibling.CodeMirror.setValue(
        localStorage.getItem('coq-snippet-' + coqdoc_ids[i]));
    }
  }

  function save_coq_snippets() {
    for (i = 0; i < coqdoc_ids.length; ++i) {
      localStorage.setItem('coq-snippet-' + coqdoc_ids[i], document.getElementById(coqdoc_ids[i]).nextSibling.CodeMirror.getValue());
    }
    alert("Coq snippets saved.");
  }

  function download_coq_snippets() {
    var chunks = []
    for (i = 0; i < coqdoc_ids.length; ++i) {
      chunks.push(document.getElementById(coqdoc_ids[i]).nextSibling.CodeMirror.getValue())
    }
    var data = new Blob(chunks, { type: "text/plain;charset=utf-8" });
    saveAs(data, 'source.v');
  }



  alignWithTop = true;
  current = 0;
  slides = [];
  function select_current() {
    for (var i = 0; i < slides.length; i++) {
      var s = document.getElementById('slideno' + i);
      if (i == current) {
        s.setAttribute('class', 'slideno selected');
      } else {
        s.setAttribute('class', 'slideno');
      }
    }
  }

  function mk_tooltip(label, text) {
    var t = document.createElement("div");
    t.setAttribute('class', 'slide-tooltip');
    t.innerHTML = label;

    var s = document.createElement("span");
    s.setAttribute('class', 'slide-tooltiptext slide-tooltip-left');
    s.innerHTML = text;

    t.appendChild(s);
    return t;
  }

  function find_hx(e) {
    for (var i = 0; i < e.children.length; i++) {
      var x = e.children[i];
      if (x.tagName == "H1" ||
        x.tagName == "H2" ||
        x.tagName == "H3" ||
        x.tagName == "H4") return x.textContent;
    }
    return null;
  }

  function init_slides() {
    var toolbar = document.getElementById('document');
    if (toolbar) {
      var tools = document.createElement("div");
      var tprev = document.createElement("div");
      var tnext = document.createElement("div");
      tools.setAttribute('id', 'tools');
      tprev.setAttribute('id', 'prev');
      tprev.setAttribute('onclick', 'prev_slide();');
      tnext.setAttribute('id', 'next');
      tnext.setAttribute('onclick', 'next_slide();');
      toolbar.prepend(tools);
      tools.appendChild(tprev);
      tools.appendChild(tnext);

      slides = document.getElementsByClassName('slide');
      for (var i = 0; i < slides.length; i++) {
        var s = document.createElement("div");
        s.setAttribute('id', 'slideno' + i);
        s.setAttribute('class', 'slideno');
        s.setAttribute('onclick', 'goto_slide(' + i + ');');
        var title = find_hx(slides[i]);
        if (title == null) {
          title = "goto slide " + i;
        }
        var t = mk_tooltip(i, title);
        s.appendChild(t)
        tools.appendChild(s);
      }
      select_current();
    } else {
      //retry later
      setTimeout(init_slides, 100);
    }
  }
  function on_screen(rect) {
    return (
      rect.top >= 0 &&
      rect.top <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function update_scrolled() {
    for (var i = slides.length - 1; i >= 0; i--) {
      var rect = slides[i].getBoundingClientRect();
      if (on_screen(rect)) {
        current = i;
        select_current();
      }
    }
  }
  function goto_slide(n) {
    current = n;
    var element = slides[current];
    console.log(element);
    element.scrollIntoView(alignWithTop);
    select_current();
  }
  function next_slide() {
    current++;
    if (current >= slides.length) { current = slides.length - 1; }
    var element = slides[current];
    console.log(element);
    element.scrollIntoView(alignWithTop);
    select_current();
  }
  function prev_slide() {
    current--;
    if (current < 0) { current = 0; }
    var element = slides[current];
    element.scrollIntoView(alignWithTop);
    select_current();
  }

  window.onload = init_slides;
  window.onbeforeunload = save_coq_snippets;
  window.onscroll = update_scrolled;
</script>

</div> <!-- /#document     -->
</div> <!-- /#code-wrapper -->
</div> <!-- /#ide-wrapper  -->

<script src="./jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script type="text/javascript">
  var coq;

  loadJsCoq('./jscoq/')
    .then(loadJs("./jscoq/node_modules/codemirror/addon/runmode/runmode"))
    .then(loadJs("./jscoq/node_modules/codemirror/addon/runmode/colorize"))
    .then(function () {
      var coqInline = document.getElementsByClassName("inline-coq");
      CodeMirror.colorize(coqInline);
    })
    .then(function () {
      coq = new CoqManager(coqdoc_ids,
        { base_path: './jscoq/',
          init_pkgs: ['init'],
          all_pkgs: ['init','math-comp']
         }
      );
    });
</script>
</body>

</html>
